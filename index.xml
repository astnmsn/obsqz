<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Publishing my notes from Obsidian on</title><link>https://astnmsn.github.io/</link><description>Recent content in Publishing my notes from Obsidian on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://astnmsn.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://astnmsn.github.io/CMU-15-445-645/Hash-Tables-for-indexing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Hash-Tables-for-indexing/</guid><description>Typical Hash Table implementation
Implements an unordered associative array that maps keys to values Uses a hash function to compute an offset into the array for a given key Space: O(n) Time: O(1) avg O(n) worst For a database constants matter, so it is important to optimize the O(1) Often worth it to trade additional space to reduce the constant factor Hash Functions How to map a large key space into a smaller domain of integers (index into the array) Lose ordering in the process Trade off between being fast and reducing collision rate Facebook XXHash is state of the art Others: CRC-64, MurmurHash, Google CityHash, Facebook XXHash, Google FarmHash Do not use cryptographic hash functions for databases, overhead is not worth it because the system does not require any of the beneficial properties Hashing Scheme How to handle key collisions after hashing Trade off between allocating a large hash table and additional instruction go get/put keys Collisions require finding another place for inserting a key/value, or traversing alternative locations when the space is filled by a different key than is being queried Static Hashing Require the DBMS to know the number of elements it wants to store, or rebuild the entire backing structures when there is overflow to allow for additional data</description></item><item><title/><link>https://astnmsn.github.io/CMU-15-445-645/Memory-Management-Buffer-Cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Memory-Management-Buffer-Cache/</guid><description>Managing the movement of data Spatial Control
Where to write pages on disk Keep data that is often accessed together, as physically close together as possible to take advantage of sequential performance of disks Temporal Control When to move data into memory and when to flush it back out to disk Disk I/O is the main bottleneck of the system, so the goal is to reduce the number of operations that require interaction with the disk The system needs to be aware which process is updating memory, so it knows when it is safe to flush (dirty records) to disk Execution engine should be unaware of this memory management, queries only require that the underlying storage system returns a pointer to the relevant data in memory (location in the buffer pool).</description></item><item><title/><link>https://astnmsn.github.io/CMU-15-445-645/Storage-Models-Compression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Storage-Models-Compression/</guid><description>Database Workloads Online Transaction Processing (OLTP) Fast operations that read and update a small amount of data at a time These systems need to serve many concurrent queries, typically on a random set of data, often related to a single entity Often, this data is generated through direct/deliberate user interaction in a system Online Analytical Processing (OLAP) Complex queries that read a lot of data to compute aggregates Queries are often run in batches to perform analysis on a large amount of data, or streaming to compute aggregates Often utilized for data science/analysis and business intelligence Single records are rarely of importance Typically combined with ETL or ELT Hybrid Transaction + Analytical Processings (HTAP) OLTP + OLAP together on the same database instance Fast transactions + analytics in one Solutions that attempt both are usually not as a good at either individual workload Relational Model Does not specify how the database system must store tuples on disk or within pages</description></item><item><title/><link>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-10-10.46.08.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-10-10.46.08.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements Cpu Registers ^3y4LCA0k
Cpu Caches ^HvtrYJft</description></item><item><title/><link>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-10-11.00.25.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-10-11.00.25.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements Directory ^5kE0x4JU
Page # ^tduVvhgp</description></item><item><title/><link>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-10-17.09.13.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-10-17.09.13.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements Size ^mJNE7tOP
Checksum ^JHOzhGp4</description></item><item><title/><link>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-11-10.11.33.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Database-Storage-2022-11-11-10.11.33.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements LF 1 ^eXaZQIyT
LF 4 ^Ksl2rhHz</description></item><item><title/><link>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Hash-Tables-for-indexing-2022-11-14-18.05.03.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Hash-Tables-for-indexing-2022-11-14-18.05.03.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements &amp;hellip;100 ^P0Ulo4dp
&amp;hellip;010 ^JPRA54UH</description></item><item><title/><link>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Storage-Models-Compression-2022-11-12-11.48.24.excalidraw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Excalidraw/CMU-15-445-645/Storage-Models-Compression-2022-11-12-11.48.24.excalidraw/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements A ^ZqBFvN4q
B ^WHLYmBdm</description></item><item><title/><link>https://astnmsn.github.io/Ideas/Topic-Ideas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Ideas/Topic-Ideas/</guid><description> Bloom Filters Types of log compaction Universal Comparison of many Schedulers (Cooperative v Preemptive) -&amp;gt; Tokio Go Concurrency Primitives How atomics work in a CPU Rust -&amp;gt; std::sync::atomic:: Ordering C++ -&amp;gt; reference MVCC DNS Load balancing algorithms Cacheing -&amp;gt; Good place to start Patterns Eviction Strategies Invalidation Cache Coherence Concurrent Data structures Distributed hash tables Overview [] Database consistency/isolation levels Content Addressing (IPFS) Merkle Dags -&amp;gt; Lessons Merkle trees Public Key Cryptography Semantic Search SIMD RocksDB Book Threading Postgres terminology -&amp;gt; Post Package deep dives tokio rayon crossbeam mio flashmap</description></item><item><title/><link>https://astnmsn.github.io/Ideas/White-Papers-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Ideas/White-Papers-List/</guid><description> Topic Web links Internal Link Lamport Clocks Paper None Cap Conjecture 12 years later None Raft Paper None Paxos Simple Live None Calvin Paper None Zookeeper Paper None Distributed Reset Link None Arrow Link None Stabilizing Token Ring Blog Post None Map Reduce Link None Dynamo Post None Spanner Paper None Internet-Scale Paper None GFS Paper None Dapper Paper None Kafka Paper None Wormhole Paper None Design Patterns Paper None Understandable Consensus Paper None Chubby Paper None Bigtable Paper None Zab Paper None Immutability Paper None Metastable Failures Paper None Megastore Paper None View-stamp Replication Original Revisited None Transactional Memory Paper None Wait-Free Synchronization Paper None IPFS Paper Summary None Networking Named Content Paper None Noria Paper Youtube None</description></item><item><title/><link>https://astnmsn.github.io/Metastable-Failures-in-Distributed-Systems-ab5acd4caa754e10a50a8abbfc7b2614/Screen_Shot_2022-03-24_at_3.21.55_PM.png/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Metastable-Failures-in-Distributed-Systems-ab5acd4caa754e10a50a8abbfc7b2614/Screen_Shot_2022-03-24_at_3.21.55_PM.png/</guid><description>![[metastable-failures-1.png]]</description></item><item><title/><link>https://astnmsn.github.io/Systems/Distributed/Calvin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Systems/Distributed/Calvin/</guid><description>Paper
Overview Calvin is a transaction scheduling and data replication layer that uses a deterministic ordering guarantee which reduces the cost associated with distributed transactions to a level that makes them feasible to run at large scale.</description></item><item><title/><link>https://astnmsn.github.io/Systems/Distributed/Metastable-Failures-in-Distributed-Systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Systems/Distributed/Metastable-Failures-in-Distributed-Systems/</guid><description>Paper ![[metastable-failures-1.png]]
Abstract &amp;amp; Intro Metastable failures: A blackswan event, outliers, no foreshocks, severe impact, much easier to explain in hindsight than to predict.</description></item><item><title/><link>https://astnmsn.github.io/Systems/Distributed/Zookeeper-Wait-free-coordination-for-Internet-Scale/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/Systems/Distributed/Zookeeper-Wait-free-coordination-for-Internet-Scale/</guid><description>Overview Zookeeper is a foundational system that enables distributed systems and workloads by providing a kernel to develop complex coordination primitives.</description></item><item><title/><link>https://astnmsn.github.io/To-Dos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/To-Dos/</guid><description>Finish CMU intro to DBs Take notes on important lectures CMU Advanced DBs Notes Reread Distributed System Books Notes Per Chapter Database Internals Book Read (Notes?</description></item><item><title>Database Storage</title><link>https://astnmsn.github.io/CMU-15-445-645/Database-Storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Database-Storage/</guid><description>Dealing with the limits of hardware ![[Database Storage 2022-11-10 10.46.08.excalidraw]]
A Disk based architecture assumes that the primary storage location of the database is on non-volatile disk This requires the system to coordinate the movement of data between disk and main memory Note: mmap bad -&amp;gt; we don&amp;rsquo;t want to rely on the OS to determine which memory should be flushed to disk, the database system has a much better understanding of a more optimal policy The cognitive and latency overhead associated with this managing this is significant (and why some still opt for mmap)</description></item></channel></rss>