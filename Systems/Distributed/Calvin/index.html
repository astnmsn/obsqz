<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Paper
Overview Calvin is a transaction scheduling and data replication layer that uses a deterministic ordering guarantee which reduces the cost associated with distributed transactions to a level that makes them feasible to run at large scale."><title>obsqz notes</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://astnmsn.github.io/icon.png><link href=https://astnmsn.github.io/styles.547fb332ce56cdc523146ba5ede80d7f.min.css rel=stylesheet><link href=https://astnmsn.github.io/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://astnmsn.github.io/js/darkmode.18cad7e2a3e6f467e27f689e56c2ce98.min.js></script>
<script src=https://astnmsn.github.io/js/util.6f22941e242efae60fd84e7c32e874fa.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script async src=https://astnmsn.github.io/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://astnmsn.github.io/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://astnmsn.github.io/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://astnmsn.github.io/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://astnmsn.github.io",fetchData=Promise.all([fetch("https://astnmsn.github.io/indices/linkIndex.e77416d15b21f300430f657f3a41b113.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://astnmsn.github.io/indices/contentIndex.2c9c5b36e2c83f2068bee29799c04e89.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://astnmsn.github.io",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://astnmsn.github.io",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/astnmsn.github.io\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://astnmsn.github.io/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://astnmsn.github.io>obsqz notes</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><p class=meta>Last updated
Jan 26, 2023
<a href=https://github.com/astnmsn/astnmsn.github.io/tree/main/content/Systems/Distributed/Calvin.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><ol><li><a href=#4-main-contributions>4 Main Contributions:</a></li></ol></li></ol><ol><li><a href=#calvin-with-disk-based-storage>Calvin with Disk-Based Storage</a></li><li><a href=#checkpointing>Checkpointing</a></li></ol></nav></details></aside><p><a href=http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf rel=noopener>Paper</a></p><a href=#overview><h1 id=overview><span class=hanchor arialabel=Anchor># </span>Overview</h1></a><p>Calvin is a transaction scheduling and data replication layer that uses a deterministic ordering guarantee which reduces the cost associated with distributed transactions to a level that makes them feasible to run at large scale.</p><p>Calvin:</p><ul><li>Supports disk-based storage</li><li>Scales near linearly on a cluster (add note of what makes it &ldquo;near&rdquo;)</li><li>No single point of failure (as is the case with many leader based systems)</li></ul><p>Calvin replicates transaction inputs rather than effects, and in so doing, is able to support multiple levels of consistency at no cost to transaction throughput</p><ul><li>Paxos-based strong consistency across distant replicas</li><li>Others</li></ul><p>Many other systems forgo transactions to enable high throughput, low latency, and availability</p><ul><li>Dynamo (Amazon)</li><li>MongoDB</li><li>CouchDB</li><li>Cassandra</li></ul><p>Others provide limited transaction support, generally within a single slice of data (local to one replica) to provide linear outward scalability</p><ul><li>Azure</li><li>Bigtable/Megastore</li><li>Oracle NoSQL database</li></ul><p>Calvin runs alongside a non-transactional storage system, meaning it does not rely on any specific storage structure, nor does it manage any of the underlying data. It elevates existing database systems, using a &ldquo;shared-nothing&rdquo; architecture, that is &ldquo;near-linearly&rdquo; scalable and provides high availability and full ACID transactions, that can even span multiple partitions.</p><p>Calvin acts as a mediator between the client and the underlying database, utilizing distributed locks to remove the need for typical distributed commit protocols to perform replication.</p><p>Calvin can sit on top of existing storage systems because it operates outside of transaction boundaries, before database level locks come into play. To enable this, an agreement on how to perform a transaction must be reached by each replica, and execution must be guaranteed. Nodes that fail can recover by communicating with other replicas that were performing the same transaction in parallel, or replay the plan of record from that node. However, to avoid divergence in the case of failure, the activity plan must deterministic.</p><p>Because Calvin guarantees the exact, ordered list of transactions to execute on all nodes, it does not require any distributed commit protocols.</p><a href=#4-main-contributions><h3 id=4-main-contributions><span class=hanchor arialabel=Anchor># </span>4 Main Contributions:</h3></a><ol><li>Transaction scheduling and data replication layer that augments non-transactional storage, introducing strong consistency and ACID transactions, while maintaining near-linear scalability & high availability.</li><li>More scalable than previous distributed commit protocols, without a single point of failure</li><li>Data prefetching during the planning phase, that allows for operations on purely disk-resident data without extending the contention footprint of a transaction for the full duration of disk lookups</li><li>A fast checkpoint scheme that helps remove the need for physical REDO logging and its associated overhead</li></ol><a href=#system-architecture><h1 id=system-architecture><span class=hanchor arialabel=Anchor># </span>System Architecture</h1></a><p>Designed to work with any storage system that accepts a basic CRUD interface</p><p>Calvin organizes the system into 3 distinct layers of processing:</p><ol><li>Sequencing<ol><li>Intercepts transaction inputs from the client</li><li>Places them onto a global transaction queue that guarantees serial ordering across the replicas</li><li>Handles replication and logging of the input sequence across nodes</li><li>Distributed across all system replicas and also partitioned across every machine within each replica. This prevents the sequencer from being a single point of failure, and removes the throughput bottleneck that a single node sequencer, serving a many node subsystem, would create.</li><li>This is the single point where replication occurs. Schedulers and storage do not need to communicate to other replicas as their actions/state are deterministic given the input from the sequencer.</li><li>Replication can be performed using asynchronous leader/follower nodes, or via a synchronous Paxos-based implementation in which all sequencers in a replication group must agree on a combined batch of transaction requests per epoch.</li></ol></li><li>Scheduling<ol><li>Utilizes the distributed locking scheme to guarantee equivalence in execution of the schedule provided by the previous layer, while allowing transactions to be performed in parallel across execution threads</li><li>Each node&rsquo;s scheduler is only responsible for locking records that are stored within the partition that the node manages</li><li>The locking protocol is very similar to traditional 2 phase locking but includes:<ol><li>Locks must be requested in the same order as the transaction requiring them appears within the sequence. This is achieved by serializing transactions within a single thread, and requesting all the locks a transaction will need throughout its life time, as it parses the global sequence of transactions</li><li>The lock manager must grant locks in the order they are requested, and only release them when the corresponding transaction completes, and releases all of its locks.</li></ol></li></ol></li><li>Storage<ol><li>Handles all physical data layout</li><li>Interacts with underlying database subsystem via the CRUD interface provided</li></ol></li></ol><p>All 3 layers can be partitioned across a cluster without any shared components between instances of each layer. They are typically run one per node, but can be adapted to fit the scaling characteristics of the underlying storage mechanism.</p><p><a class="internal-link broken">calvin-1.png</a>
Process ordering:</p><ol><li>Requests are compiled into 10 millisecond batches by Sequencers and replicated to the sequencers of the corresponding partition on replica nodes.</li><li>Sequencers send these batches to every partition within their replica with the following info:<ol><li>Sequencer unique node ID</li><li>The epoch number (which is synchronously incremented across the entire system)</li><li>All transaction inputs collected that the recipient will need to participate in</li></ol></li><li>Scheduler interleaves the transactions sent by the sequencer within their replica, thus constructing a global ordering</li><li>For each transaction in the ordering the scheduler grants the transaction all of its required locks, and hands it off to a worker thread to be executed.</li><li>Each worker thread proceeds in five phases:<ol><li>Read/write set analysis<ol><li>The elements of the r/w set that exist in the partition for the node</li><li>The set of nodes at which elements of the write set are stored</li><li>Active participants: those where writes occur</li><li>Passive participants: those where only reads occur</li></ol></li><li>Perform local reads</li><li>Serve remote reads<ol><li>Forward to parallel worker threads on other actively participating nodes</li></ol></li><li>Collect remote reads</li><li>Execute (Transaction logic and applying writes)<ol><li>Only local writes (to the nodes partition)</li></ol></li></ol></li></ol><p>Calvin does not natively support transactions which must perform reads in order to determine the read/write set because the deterministic locking protocol it is based upon requires that the set of locks needed by a transaction be known before the transaction is executed.</p><p>To get around this Calvin does allow for Optimistic Lock Location Prediction; an inexpensive, low-isolation, unreplicated, read-only query that can be run prior to the transaction to uncover the full read/write. Because the results of these queries are not guarded by the transaction&rsquo;s boundary, they must be rechecked on execution, and the process restarted. This is commonly the case for secondary indexes (but because secondary indexes are applied to values that should be rarely updated, the process should not often need be restarted).</p><a href=#calvin-with-disk-based-storage><h2 id=calvin-with-disk-based-storage><span class=hanchor arialabel=Anchor># </span>Calvin with Disk-Based Storage</h2></a><p>Because Calvin must follow the transaction order determined by the scheduler, it cannot reorder transactions on the fly (as in many traditional databases). This means that it cannot move non-overlapping transactions up in the order if others are stalled (for disk access).</p><p>To remedy this Calvin incurs the cost prior to acquiring locks. It introduces a delay (fixed or deterministic) into the scheduling process to account for any cold-fetch of data from disk. It issues a request to preload this data into memory so that it will be resident when the transaction actually occurs.</p><p>Tuning for the length of this delay is highly important to performance. Too low and the system throughput will suffer the same contention issues that exist without the prefetch. Too high and the system could overload memory while waiting for longer than is necessary and adds un-utilized latency.</p><p>The other component that proves non-trivial is determining which documents are already resident in memory. A lookup table must be stored at all sequencers which becomes intractable at large scale. The only alternative to not tracking, is to introduce the delay for all transactions.</p><a href=#checkpointing><h2 id=checkpointing><span class=hanchor arialabel=Anchor># </span>Checkpointing</h2></a><p>As with many systems that maintain a log of transactions, it is possible to reconstruct a database by replaying the full list of transactions in order. However, this is generally very inefficient. Instead Calvin, and most other systems, take periodic snapshots of the database state, and replay only the transaction after the snapshot.</p><p>Remote reads to failed machines within a replica are likely to slow or halt until the afflicted machine is able to replay the transaction log from the point of the last snapshot.</p><p>Naive Synchronous Checkpointing:</p><ul><li>Snapshot is generated at a point in time from a replica. Client interaction is unaffected during this period, assuming there are no other failures in the system.</li><li>The snapshot replica may fall significantly behind the leader, and catching up may prove difficult in high load systems. This becomes especially concerning if the leader fails during the process, and the snapshot is called into action.</li></ul><p>Asynchronous Zig-Zag</p><ul><li>Two copies of each record are stored, plus two additional bits that signify which copy to read and which to overwrite.</li><li>During normal operation, the read bit is set equivalent to the write bit to ensure the newest value is read.</li><li>At the time of a checkpoint, the write bit is set to the opposite of the read bit for all values, so that new writes will not blast the values present at the time of the checkpoint. This requires a period of quiescence (only DBA operations can be performed) to ensure consistency.</li><li>The frozen copy (that is not being written to, or read from) is used to generate the snapshot.</li><li>This method retains the last snapshot value at all points in time in the ¬write copy.</li><li>Calvin&rsquo;s improvement:<ul><li>Because of its global serial order, it does not require quiescence.</li><li>Calvin can specify a point the serial order, around which it can start storing multiple versions of records (before and after).</li><li>Once all before transactions have completed, those versions become immutable and a thread can begin checkpointing them to disk.</li><li>To cleanup the, all records that have both a before and after version stored can dispose of the before version.</li></ul></li></ul><p>Full Multiversioning Storage</p><ul><li>Allows read only queries to be executed without acquiring locks</li><li>Calvin can simply scan (SELECT *) over the database and log the result to a file</li></ul></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script async src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://astnmsn.github.io/js/graph.2d9e48dbe7ea47c0ef1c58296ce14448.js></script></div></div><div id=contact_buttons><footer><p>Made by Austin Mason using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, © 2023</p><ul><li><a href=https://astnmsn.github.io>Home</a></li><li><a href=https://github.com/astnmsn>GitHub</a></li></ul></footer></div></div></body></html>