<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CMU 15-445-645s on</title><link>https://astnmsn.github.io/cmu-15-445-645/</link><description>Recent content in CMU 15-445-645s on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://astnmsn.github.io/cmu-15-445-645/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://astnmsn.github.io/CMU-15-445-645/Hash-Tables-for-indexing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Hash-Tables-for-indexing/</guid><description>Typical Hash Table implementation
Implements an unordered associative array that maps keys to values Uses a hash function to compute an offset into the array for a given key Space: O(n) Time: O(1) avg O(n) worst For a database constants matter, so it is important to optimize the O(1) Often worth it to trade additional space to reduce the constant factor Hash Functions How to map a large key space into a smaller domain of integers (index into the array) Lose ordering in the process Trade off between being fast and reducing collision rate Facebook XXHash is state of the art Others: CRC-64, MurmurHash, Google CityHash, Facebook XXHash, Google FarmHash Do not use cryptographic hash functions for databases, overhead is not worth it because the system does not require any of the beneficial properties Hashing Scheme How to handle key collisions after hashing Trade off between allocating a large hash table and additional instruction go get/put keys Collisions require finding another place for inserting a key/value, or traversing alternative locations when the space is filled by a different key than is being queried Static Hashing Require the DBMS to know the number of elements it wants to store, or rebuild the entire backing structures when there is overflow to allow for additional data</description></item><item><title/><link>https://astnmsn.github.io/CMU-15-445-645/Memory-Management-Buffer-Cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Memory-Management-Buffer-Cache/</guid><description>Managing the movement of data Spatial Control
Where to write pages on disk Keep data that is often accessed together, as physically close together as possible to take advantage of sequential performance of disks Temporal Control When to move data into memory and when to flush it back out to disk Disk I/O is the main bottleneck of the system, so the goal is to reduce the number of operations that require interaction with the disk The system needs to be aware which process is updating memory, so it knows when it is safe to flush (dirty records) to disk Execution engine should be unaware of this memory management, queries only require that the underlying storage system returns a pointer to the relevant data in memory (location in the buffer pool).</description></item><item><title/><link>https://astnmsn.github.io/CMU-15-445-645/Storage-Models-Compression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Storage-Models-Compression/</guid><description>Database Workloads Online Transaction Processing (OLTP) Fast operations that read and update a small amount of data at a time These systems need to serve many concurrent queries, typically on a random set of data, often related to a single entity Often, this data is generated through direct/deliberate user interaction in a system Online Analytical Processing (OLAP) Complex queries that read a lot of data to compute aggregates Queries are often run in batches to perform analysis on a large amount of data, or streaming to compute aggregates Often utilized for data science/analysis and business intelligence Single records are rarely of importance Typically combined with ETL or ELT Hybrid Transaction + Analytical Processings (HTAP) OLTP + OLAP together on the same database instance Fast transactions + analytics in one Solutions that attempt both are usually not as a good at either individual workload Relational Model Does not specify how the database system must store tuples on disk or within pages</description></item><item><title>Database Storage</title><link>https://astnmsn.github.io/CMU-15-445-645/Database-Storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://astnmsn.github.io/CMU-15-445-645/Database-Storage/</guid><description>Dealing with the limits of hardware ![[Database Storage 2022-11-10 10.46.08.excalidraw]]
A Disk based architecture assumes that the primary storage location of the database is on non-volatile disk This requires the system to coordinate the movement of data between disk and main memory Note: mmap bad -&amp;gt; we don&amp;rsquo;t want to rely on the OS to determine which memory should be flushed to disk, the database system has a much better understanding of a more optimal policy The cognitive and latency overhead associated with this managing this is significant (and why some still opt for mmap)</description></item></channel></rss>